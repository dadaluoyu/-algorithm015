学习笔记


最长回文子串
一个是初始化长度为1的区间
一个是初始化长度为0的区间


动态规划方法实现

最关键的这句话很重要
is_palindrome[i][j]= (s[i]==s[j]) and is_palindrome[i+1][j-1]
这个s[i]==s[j]是一个判断条件，如果两个相等，那个is_palindrome[i][j]就是true
然后is_palindrome[i+1][j-1]就是内部的子串是不是true
如果都符合，长度+1
如果是最长的，就记录下来

然后长度可以是1到n
对于每个长度，搜索对应的范围
由于是不是回文子串都记录在二维数组is_palindrome里面了，所以不会重复到O（n^3）这样

一开始把is_palindrome改成全false
然后自己单个字符是true

  for i in range(1,n):
            is_palindrome[i][i-1]=True
            #only works when length==1, that i+1 will bigger than j-1
这个就很好理解了，length为1时，检测回文子串比如“aa”时，由于is_palindrome[i][j]的下一级is_palindrome[i+1][j-1]会没有东西，出现i+1>j-1的情况，但是形如“aa”是可行的回文子串，所以在初始化的时候考虑这个条件


————————————

LC 120 题解

这题DP的思路有几个层次
1.自顶向下，建立额外三角形空间二维DP
2.直接在原三角形上修改，二维DP
3.自底向上在原三角形上修改，不消费额外空间
4.用res数组复制三角形最后一行，在res数组上迭代

只需要从倒数第二行开始迭代
且完美解决只有一行的情况，也在范围内

第4种方法，因为层与层之间除了记录结果外没有额外的依赖关系，第一层只和第二层交互，和第三层互不影响
因此只需要一维数组就能存储全部的结果

n = len(triangle[-1])
res数组中，res[n - 2]被更新1次，res[0] 被更新 n - 1次
每次内层循环，只更新当前层对应的前j个数
到第一层只更新res[0]
懂了，更新前，更新后，自我迭代

每次更新传递的是上一层到底层的最短距离
到第一层就是从顶到底的最短距离了

内层循环的下标也要注意，第一层至少执行1次，那么i = 0时执行1次，for j in range(i + 1)，里面的就是i + 1 而不是i

这里的i+1 =len(triangle[i]，就是遍历这一层的所有元素！
边界条件要搞清楚

**自底向上和自顶向下最大的区别**是
自顶向下时左右边界的三角形在左边界没有左上，右边界没有右上，要进行状态判断及处理，如if j == 0 或者 if j == i
代码逻辑的复杂度会上升
而这本身是没有必要的
因为自底向上的全部值，把三角形倒过来看，都有左上和右上，最后回归到1，问题是有重复性和一致性的
可以用统一的模式解决
非常的精妙