学习笔记

LC 120 题解

这题DP的思路有几个层次
1.自顶向下，建立额外三角形空间二维DP
2.直接在原三角形上修改，二维DP
3.自底向上在原三角形上修改，不消费额外空间
4.用res数组复制三角形最后一行，在res数组上迭代

只需要从倒数第二行开始迭代
且完美解决只有一行的情况，也在范围内

第4种方法，因为层与层之间除了记录结果外没有额外的依赖关系，第一层只和第二层交互，和第三层互不影响
因此只需要一维数组就能存储全部的结果

n = len(triangle[-1])
res数组中，res[n - 2]被更新1次，res[0] 被更新 n - 1次
每次内层循环，只更新当前层对应的前j个数
到第一层只更新res[0]
懂了，更新前，更新后，自我迭代

每次更新传递的是上一层到底层的最短距离
到第一层就是从顶到底的最短距离了

内层循环的下标也要注意，第一层至少执行1次，那么i = 0时执行1次，for j in range(i + 1)，里面的就是i + 1 而不是i

这里的i+1 =len(triangle[i]，就是遍历这一层的所有元素！
边界条件要搞清楚

**自底向上和自顶向下最大的区别**是
自顶向下时左右边界的三角形在左边界没有左上，右边界没有右上，要进行状态判断及处理，如if j == 0 或者 if j == i
代码逻辑的复杂度会上升
而这本身是没有必要的
因为自底向上的全部值，把三角形倒过来看，都有左上和右上，最后回归到1，问题是有重复性和一致性的
可以用统一的模式解决
非常的精妙